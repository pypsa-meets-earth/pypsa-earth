# SPDX-FileCopyrightText:  PyPSA-Earth and PyPSA-Eur Authors
#
# SPDX-License-Identifier: CC0-1.0

version: 0.4.1

monte_carlo:
  # Description: Specify Monte Carlo sampling options for uncertainty analysis.
  # Define the option list for Monte Carlo sampling.
  # Make sure add_to_snakefile is set to true to enable Monte-Carlo
  options:
    add_to_snakefile: false # When set to true, enables Monte Carlo sampling
    samples: 9 # number of optimizations. Note that number of samples when using scipy has to be the square of a prime number
    sampling_strategy: "chaospy" # "pydoe2", "chaospy", "scipy", packages that are supported
    seed: 42 # set seedling for reproducibilty
  # Uncertanties on any PyPSA object are specified by declaring the specific PyPSA object under the key 'uncertainties'.
  # For each PyPSA object, the 'type' and 'args' keys represent the type of distribution and its argument, respectively.
  # Supported distributions types are uniform, normal, lognormal, triangle, beta and gamma.
  # The arguments of the distribution are passed using the key 'args'  as follows, tailored by distribution type
  # normal: [mean, std], lognormal: [mean, std], uniform: [lower_bound, upper_bound],
  # triangle: [mid_point (between 0 - 1)], beta: [alpha, beta], gamma: [shape, scale]
  # More info on the distributions are documented in the Chaospy reference guide...
  # https://chaospy.readthedocs.io/en/master/reference/distribution/index.html
  # An abstract example is as follows:
  # {pypsa network object, e.g. "loads_t.p_set"}:
  # type: {any supported distribution among the previous: "uniform", "normal", ...}
  # args: {arguments passed as a list depending on the distribution, see the above and more at https://pypsa.readthedocs.io/}
  uncertainties:
    loads_t.p_set:
      type: uniform
      args: [0, 1]
    generators_t.p_max_pu.loc[:, n.generators.carrier == "onwind"]:
      type: lognormal
      args: [1.5]
    generators_t.p_max_pu.loc[:, n.generators.carrier == "solar"]:
      type: beta
      args: [0.5, 2]

solving:
  options:
    formulation: kirchhoff
    load_shedding: true
    noisy_costs: true
    min_iterations: 4
    max_iterations: 6
    clip_p_max_pu: 0.01
    skip_iterations: true
    track_iterations: false
    # nhours: 10

  solver:
    name: gurobi
    options: gurobi-default

  solver_options:
    highs-default:
      # refer to https://ergo-code.github.io/HiGHS/dev/options/definitions/
      threads: 4
      solver: "ipm"
      run_crossover: "off"
      small_matrix_value: 1e-6
      large_matrix_value: 1e9
      primal_feasibility_tolerance: 1e-5
      dual_feasibility_tolerance: 1e-5
      ipm_optimality_tolerance: 1e-4
      parallel: "on"
      random_seed: 123
    gurobi-default:
      threads: 4
      method: 2 # barrier
      crossover: 0
      BarConvTol: 1.e-6
      Seed: 123
      AggFill: 0
      PreDual: 0
      GURO_PAR_BARDENSETHRESH: 200
    gurobi-numeric-focus:
      NumericFocus: 3 # Favour numeric stability over speed
      method: 2 # barrier
      crossover: 0 # do not use crossover
      BarHomogeneous: 1 # Use homogeneous barrier if standard does not converge
      BarConvTol: 1.e-5
      FeasibilityTol: 1.e-4
      OptimalityTol: 1.e-4
      ObjScale: -0.5
      threads: 8
      Seed: 123
    gurobi-fallback: # Use gurobi defaults
      crossover: 0
      method: 2 # barrier
      BarHomogeneous: 1 # Use homogeneous barrier if standard does not converge
      BarConvTol: 1.e-5
      FeasibilityTol: 1.e-5
      OptimalityTol: 1.e-5
      Seed: 123
      threads: 8
    cplex-default:
      threads: 4
      lpmethod: 4 # barrier
      solutiontype: 2 # non basic solution, ie no crossover
      barrier.convergetol: 1.e-5
      feasopt.tolerance: 1.e-6
    copt-default:
      Threads: 8
      LpMethod: 2
      Crossover: 0
    cbc-default: {} # Used in CI
    glpk-default: {} # Used in CI

  mem: 30000 #memory in MB; 20 GB enough for 50+B+I+H2; 100 GB for 181+B+I+H2
